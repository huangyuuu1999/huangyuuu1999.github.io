# 快速排序
快速排序是一种分治（divide-and-conquer）的排序算法。

1960年前后被英国的 Tony Hoare 发明。

## basic idea

选一个数字作为“轴” ，对乱序的数组进行 “划分”，使得大于轴的数字都在右边，小于轴的数字都在左边。
再分别对左边和右边的部分进行排序。

将排序整个数组的问题，变成了：划分操作 + 两个相同性质的小问题。

```c
// 伪代码
void quickSort(arr []int) {
    if len(arr) <= 1 {
        return;
    }
    partition(arr); // 分区操作
    someSortfunc(leftPart); // 排序左部
    someSortfunc(rightPart); // 排序右部
} 
```
排序左边和右边的时候，可以用quickSort本身，这样就是递归来解决；也可以不使用quickSort而使用其他的排序算法，例如当某一边的元素数目特别少，可以使用简单的冒泡之类的算法更加简单快速。

### 函数原型

`quicksort(A, lo, hi)` 函数声明中的 `lo` 和 `hi` 是什么？

在排序的时候，除了会对整个数组进行排序，有时候也有对数组的一个部分进行排序的需求。所以为了更加通用，函数原型定义为 `quicksort(arr, start_index, end_index)` 表示对数组arr[start_index..end_index]闭区间上的元素进行排序。

## 分区操作

在上面的伪代码中，我们看到，快速排序中，分区操作很关键，如果我们写出了分区操作，也就写出了快速排序。

回顾一下，分区操作做什么：选一个数当做轴，一般称为`pivot`，经过一系列操作，把小于它的数放左边，大于它的放右边。

等于它的元素，我们放在中间。

<!-- 这个描述看起来很清楚了，但是注意：我们是不是没有提到“等于它的”放在哪？

“一定是中间！” ———— 这很明智，但不是唯一的答案。

说不定已经引起了困惑了————“难道等于pivot的数字还能放到最后面不成？”，好吧，让我来重申一下！

分区操作要做什么？

分区操作实际上把数组分成两个部分，好让我们得到两个更容易解决的子问题。
 -->

### 最简单的实现
这里的实现是最简单的，也是最直观的，主要是为了让我们明白分区操作在干什么，它实际上不是最优的，我们会在后面优化。

```py
# quick.py
def partition(arr, p, r):
    assert p <= r
    pivot = arr[0]
    left_part, right_part = [], []  # 保存左边和右边
    for n in arr:
        if n < pivot:
            left_part.append(n)
        elif n > pivot:
            right_part.append(n)
    new_arr = left_part + [pivot] + right_part  # 更新原来的数组
    for i in range(len(arr)):
        arr[i] = new_arr[i]
    return new_arr


arr = [5, 8, 2, 1, 9, 3, 6, 4]
print("before partition:", arr)
new_arr = partition(arr, 0, len(arr) - 1)
print("after  partition:", arr)

print("returned new arr:", new_arr)
"""
before partition: [5, 8, 2, 1, 9, 3, 6, 4]
after  partition: [2, 1, 3, 4, 5, 8, 9, 6]
returned new arr: [2, 1, 3, 4, 5, 8, 9, 6]
"""
```

这个分区算法，使用了额外的空间，这就是他最大的缺点，真正的分区算法，应该是原地的，仅仅使用O(1)的额外空间。

下面的 Lomuto 分区方法和 Hoare 分区方法（包括他们的变种）是生产环境中最为常见的分区方法。

### Lomuto 分区方案

实际上最早的分区方案是 Hoare 本人，也就是快排的发明人的 Hoare 分区，但是 Lomuto 分区算法相对容易理解，在《算法导论》书中也是以 Lomuto 分区算法来讲解的。

函数功能：
选一个数字x，进行一系列操作，最终返回一个下标，这个下标就是x最后的位置，在x左边的都小于x，在x右边的都大于x。

### Hoare 分区方案
Hoare方法的核心在于，不是以某个数字为轴。

函数功能：
选一个数字x，进行一系列操作，最终返回一个下标，在 **这个下标以及他左侧的** 数字都小于x，右侧的都大于等于x。

最初选的轴x的位置，并不保证在最中间，所以返回的下标，也和轴x没有任何关系，这个下标仅仅是一个分界点而已。

### 挖空法

## 快排时间复杂度分析

平均O(nlogn)，最坏O(n^2)。
最好呢？
什么时候最坏？已经有序？还是逆序？

## 快排的稳定性

## 三轴快排

### 荷兰国旗问题

## 快速选择算法
